#!/usr/bin/env python3
"""
Protobuf compilation script for Sourccey robot.
This script compiles all .proto files into Python modules.
"""

import importlib
import sys
import subprocess
import pathlib
import shutil
from typing import List, Tuple

def check_dependencies() -> bool:
    """Check if required dependencies are installed."""
    try:
        import grpc_tools
        return True
    except ImportError:
        print("Error: grpc_tools not found. Please install it with:")
        print("pip install grpcio-tools")
        return False

def get_proto_files() -> List[str]:
    """Get list of .proto files in the current directory."""
    proto_files = []
    current_dir = pathlib.Path(__file__).parent

    for file in current_dir.glob("*.proto"):
        proto_files.append(file.name)

    return sorted(proto_files)

def clean_generated_files(output_dir: str = "generated"):
    """Clean existing generated files to ensure fresh compilation."""
    current_dir = pathlib.Path(__file__).parent
    output_path = current_dir / output_dir

    if output_path.exists():
        print(f"Cleaning existing generated files in {output_path}...")
        shutil.rmtree(output_path)

    output_path.mkdir(exist_ok=True)
    print(f"✓ Created clean output directory: {output_path}")

def compile_proto_files(proto_files: List[str], output_dir: str = "generated") -> Tuple[bool, List[str]]:
    """
    Compile protobuf files to Python modules.

    Args:
        proto_files: List of .proto file names
        output_dir: Output directory for generated Python files

    Returns:
        Tuple of (success, list of generated files)
    """
    current_dir = pathlib.Path(__file__).parent
    output_path = current_dir / output_dir

    # Ensure output directory exists
    output_path.mkdir(exist_ok=True)

    generated_files = []
    success = True

    for proto_file in proto_files:
        print(f"Compiling {proto_file}...")

        try:
            # Run protoc command with proper flags
            cmd = [
                sys.executable, "-m", "grpc_tools.protoc",
                f"-I{current_dir}",  # Include path for imports
                f"--python_out={output_path}",  # Python output
                f"--pyi_out={output_path}",  # Python type stubs
                str(current_dir / proto_file)
            ]

            print(f"  Running: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)

            # Get the generated Python file name
            python_file = proto_file.replace(".proto", "_pb2.py")
            pyi_file = proto_file.replace(".proto", "_pb2.pyi")
            generated_python = output_path / python_file
            generated_pyi = output_path / pyi_file

            if generated_python.exists():
                generated_files.append(str(generated_python))
                print(f"  ✓ Generated: {generated_python}")
                if generated_pyi.exists():
                    print(f"  ✓ Generated type stubs: {generated_pyi}")
            else:
                print(f"  ✗ Failed to generate: {generated_python}")
                success = False

        except subprocess.CalledProcessError as e:
            print(f"  ✗ Error compiling {proto_file}:")
            print(f"    stdout: {e.stdout}")
            print(f"    stderr: {e.stderr}")
            success = False
        except Exception as e:
            print(f"  ✗ Unexpected error compiling {proto_file}: {e}")
            success = False

    return success, generated_files

def create_init_file(output_dir: str = "generated"):
    """Create __init__.py file in the generated directory."""
    current_dir = pathlib.Path(__file__).parent
    output_path = current_dir / output_dir
    init_file = output_path / "__init__.py"

    init_content = '''"""
Generated protobuf modules for Sourccey robot.
This module contains the compiled protobuf classes.

Auto-generated by compile.py - do not edit manually.
"""

# Import all generated modules
try:
    from . import sourccey_pb2

    __all__ = [
        'sourccey_pb2'
    ]
except ImportError as e:
    print(f"Warning: Could not import protobuf modules: {e}")
    print("Make sure to run compile.py first to generate the protobuf files.")
'''
    with open(init_file, 'w') as f:
        f.write(init_content)

    print(f"✓ Created: {init_file}")

def verify_compilation(generated_files: List[str]) -> bool:
    """Verify that the generated files can be imported."""
    print("\nVerifying compilation...")

    success = True
    if not generated_files:
        print("  ✗ No generated files to verify")
        return False

    generated_dir = pathlib.Path(generated_files[0]).parent

    # Add the generated directory to Python path temporarily
    original_path = sys.path.copy()
    sys.path.insert(0, str(generated_dir))

    try:
        for file_path in generated_files:
            try:
                module_name = pathlib.Path(file_path).stem
                module = importlib.import_module(module_name)
                print(f"  ✓ {module_name} imports successfully")
            except Exception as e:
                print(f"  ✗ {module_name} failed to import: {e}")
                success = False
    finally:
        # Restore original Python path
        sys.path = original_path

    return success

def test_protobuf_functionality():
    """Test that the protobuf classes can be instantiated and used."""
    print("\nTesting protobuf functionality...")

    generated_dir = pathlib.Path(__file__).parent / "generated"
    original_path = sys.path.copy()
    sys.path.insert(0, str(generated_dir))

    try:
        # Test sourccey_pb2
        import sourccey_pb2

        # Test MotorJoint
        motor_joint = sourccey_pb2.MotorJoint()
        motor_joint.shoulder_pan = 1.0
        motor_joint.shoulder_lift = 2.0
        motor_joint.elbow_flex = 3.0
        motor_joint.wrist_flex = 4.0
        motor_joint.wrist_roll = 5.0
        motor_joint.gripper = 6.0
        print("  ✓ MotorJoint can be created and populated")

        # Test BaseVelocity
        base_velocity = sourccey_pb2.BaseVelocity()
        base_velocity.x_vel = 1.0
        base_velocity.y_vel = 2.0
        base_velocity.z_vel = 3.0
        base_velocity.theta_vel = 4.0
        print("  ✓ BaseVelocity can be created and populated")

        # Test CameraImage with simplified structure
        camera_image = sourccey_pb2.CameraImage()
        camera_image.name = "test_camera"
        camera_image.image_data = b"fake_jpeg_data"
        print("  ✓ CameraImage can be created and populated with simplified structure")

        # Test SourcceyRobotState with single cameras field
        robot_state = sourccey_pb2.SourcceyRobotState()
        robot_state.left_arm_joints.CopyFrom(motor_joint)
        robot_state.right_arm_joints.CopyFrom(motor_joint)
        robot_state.base_velocity.CopyFrom(base_velocity)
        robot_state.cameras.append(camera_image)
        print("  ✓ SourcceyRobotState can be created and populated with single cameras field")

        # Test SourcceyRobotAction
        robot_action = sourccey_pb2.SourcceyRobotAction()
        robot_action.left_arm_target_joints.CopyFrom(motor_joint)
        robot_action.right_arm_target_joints.CopyFrom(motor_joint)
        robot_action.base_target_velocity.CopyFrom(base_velocity)
        print("  ✓ SourcceyRobotAction can be created and populated")

        # Test serialization
        serialized_state = robot_state.SerializeToString()
        deserialized_state = sourccey_pb2.SourcceyRobotState()
        deserialized_state.ParseFromString(serialized_state)
        print("  ✓ Serialization and deserialization works")

        # Verify the cameras field structure
        if len(deserialized_state.cameras) == 1:
            print("  ✓ Cameras field correctly uses repeated CameraImage structure")
            # Verify the simplified CameraImage structure
            test_camera = deserialized_state.cameras[0]
            if test_camera.name == "test_camera" and test_camera.image_data == b"fake_jpeg_data":
                print("  ✓ Simplified CameraImage structure works correctly")
            else:
                print("  ✗ CameraImage structure mismatch")
                return False
        else:
            print("  ✗ Cameras field structure mismatch")
            return False

        return True

    except Exception as e:
        print(f"  ✗ Functionality test failed: {e}")
        import traceback
        traceback.print_exc()
        return False
    finally:
        sys.path = original_path

def validate_proto_structure():
    """Validate that the proto file structure matches expectations."""
    print("\nValidating proto file structure...")

    current_dir = pathlib.Path(__file__).parent
    proto_file = current_dir / "sourccey.proto"

    if not proto_file.exists():
        print("  ✗ sourccey.proto file not found")
        return False

    try:
        with open(proto_file, 'r') as f:
            content = f.read()

        # Check for expected structure
        if "repeated CameraImage cameras = 4;" in content:
            print("  ✓ Proto file has correct cameras field structure")
        else:
            print("  ✗ Proto file missing expected cameras field structure")
            return False

        if "message SourcceyRobotState" in content:
            print("  ✓ Proto file contains SourcceyRobotState message")
        else:
            print("  ✗ Proto file missing SourcceyRobotState message")
            return False

        # Check for simplified CameraImage structure
        if "bytes image_data = 2;" in content:
            print("  ✓ Proto file has simplified CameraImage structure")
        else:
            print("  ✗ Proto file missing simplified CameraImage structure")
            return False

        return True

    except Exception as e:
        print(f"  ✗ Error validating proto file: {e}")
        return False

def compile_sourccey_protobuf():
    """Main compilation function."""
    print("Sourccey Protobuf Compiler")
    print("=" * 40)

    # Check dependencies
    if not check_dependencies():
        sys.exit(1)

    # Validate proto structure
    if not validate_proto_structure():
        print("\n❌ Proto file validation failed!")
        sys.exit(1)

    # Get proto files
    proto_files = get_proto_files()
    if not proto_files:
        print("No .proto files found in current directory.")
        sys.exit(1)

    print(f"Found {len(proto_files)} proto files:")
    for proto_file in proto_files:
        print(f"  - {proto_file}")

    # Clean existing generated files
    clean_generated_files()

    # Compile proto files
    print(f"\nCompiling proto files...")
    success, generated_files = compile_proto_files(proto_files)

    if not success:
        print("\n❌ Compilation failed!")
        sys.exit(1)

    # Create __init__.py file
    create_init_file()

    # Verify compilation
    verify_success = verify_compilation(generated_files)

    # Test functionality
    functionality_success = test_protobuf_functionality()

    if verify_success and functionality_success:
        print("\n✅ All protobuf files compiled successfully!")
        print(f"Generated {len(generated_files)} Python modules in 'generated/' directory.")
        print("\nYou can now use the protobuf methods in Sourccey classes.")
        print("\nNote: The cameras field now uses a single repeated CameraImage structure")
        print("with simplified fields (name and image_data only) as defined in the proto file.")
    else:
        print("\n⚠️  Compilation completed but some tests failed.")
        if not verify_success:
            print("  - Module import verification failed")
        if not functionality_success:
            print("  - Functionality testing failed")
        sys.exit(1)

def main():
    compile_sourccey_protobuf()

if __name__ == "__main__":
    main()
